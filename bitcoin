def get_balance(ticker):
    balances = upbit.get_balances()
    for b in balances:
        if b['currency'] == ticker:
            if b['balance'] is not None:    
                return float(b['balance'])
            else:
                return 0


    
##half-half
#def half_half(Ticker):
import time
import pyupbit
import datetime
import key
import numpy as np
import pandas as pd
flag = "KRW"
a=0
b=0
z=0

while True:
    try:
        now = datetime.datetime.now()
        access = key.access_key
        secret = key.secret_key
        upbit = pyupbit.Upbit(access, secret)
        price_BTC = pyupbit.get_current_price("BTC-ETH")
        price_KRW = pyupbit.get_current_price(["KRW-BTC", "KRW-ETH", "KRW-XRP"])

        buy_price = float(format(upbit.get_amount('ALL')))*1.0005
        sell_price = float(pyupbit.get_current_price(["KRW-BTC"]))*float(format(upbit.get_balance(ticker="KRW-BTC")))*0.9995
        sell_cond = sell_price-buy_price
        
        num_count = 5


        ticker = "KRW-BTC"
        ticker_origin = "BTC"
        
        n = 0
        m=0
        k=0
        j=0
     
        
        df = pyupbit.get_ohlcv(ticker,interval="minute1",count=num_count)
        df2 = pyupbit.get_ohlcv(ticker,interval="minute1",count=15)
        s_mid=(df['open']+df['close'])/2
        #s_mid=(df['open']+df['close'])/2
        h_mid=(df['high']+df['low'])/2
        gab=max(df2['high'])
        s=[]
        h=[]
        red=df['close']-df['open']  #양수면 빨강, 음수면 파랑
        #red=df['close']-df['open']
        
        plus = []
        minus = []
        

####매수 조건
        for i in list(range(1,num_count)):
            if (s_mid[-i]-s_mid[-i-1]<0):
                n=n+1   #중점이 하락시
            elif (s_mid[-i]-s_mid[-i-1]==0 and ((df['high'][-i]+df['low'][-i])/2) - ((df['high'][-i-1]+df['low'][-i-1])/2)<=0):
                n=n+1   #중점 같을경우 고점저점의 중점 같거나 하락시
            elif (s_mid[-i]-s_mid[-i-1]==0 and ((df['high'][-i]+df['low'][-i])/2) - ((df['high'][-i-1]+df['low'][-i-1])/2)>0):
                if (df['low'][-i]>df['low'][-i-1]):
                    if (i==1 and red[-1]>0):
                        m=m+1   #중점 같을 경우 고점저점의 중점 상승시 & 최근이 빨강일때
                    else:
                        k=k+1
            elif (s_mid[-i]-s_mid[-i-1]>0):
                if (s_mid[-i]-s_mid[-i-1]>=5000):
                    n=n+1   #중점 미미하게 상승
                elif (df['low'][-i]<df['low'][-i-1] and red[-i]>0):
                    k=k+1   #중점 상승, 저점 하락, 마지막 빨강
                elif (df['low'][-i]<df['low'][-i-1] and red[-i]<=0):
                    n=n+1   #중점 상승, 저점 하락, 마지막 파랑 또는 -
                elif (df['low'][-i]>=df['low'][-i-1] and red[-i]<=0):
                    k=k+1   #중점 상승, 저점 같거나 상승, 마지막 파랑 또는 -
                elif (df['low'][-i]>=df['low'][-i-1] and red[-i]>0):
                    if (i==1):
                        m=m+1   #중점 상승, 저점 같거나 상승, 마지막 빨강
                    else:
                        k=k+1
                
        for i in list(range(1,num_count)):
            if red[i]>0:
                j=j+1
        
        if (float(format(upbit.get_balance(ticker="KRW")))>=6000):
            if (n==4):
                    print("falling")
            elif (n==3 and m==1 and gab-df['high'][-1]<=150000 and j<3):
                    print(now)
                    upbit.buy_market_order(ticker,get_balance("KRW")*0.9994)
                    buy=buy_price
                    print("buy price+fee : " , buy_price)
                    print("buy price : ", float(format(upbit.get_amount('ALL'))))
                    print("fee : ", float(format(upbit.get_amount('ALL')))*0.0005)
          
        n=0
        m=0
        k=0
        j=0
        
##매도 조건
        for i in list(range(1,num_count)):
            if (s_mid[-i]-s_mid[-i-1]>0):
                n=n+1   #중점이 상승시
            elif (s_mid[-i]-s_mid[-i-1]==0 and ((df['high'][-i]+df['low'][-i])/2) - ((df['high'][-i-1]+df['low'][-i-1])/2)>=0):
                n=n+1   #중점 같을경우 고점저점의 중점 같거나 상승시
            elif (s_mid[-i]-s_mid[-i-1]==0 and ((df['high'][-i]+df['low'][-i])/2) - ((df['high'][-i-1]+df['low'][-i-1])/2)<0):
                if (df['low'][-i]<df['low'][-i-1]):
                    if (i==1 and red[-1]<0):
                        m=m+1   #중점 같을 경우 고점저점의 중점 하락시 & 최근이 파랑
                    else:
                        k=k+1
            elif (s_mid[-i]-s_mid[-i-1]<0):
                if (s_mid[-i]-s_mid[-i-1]<=5000):
                    n=n+1   #중점 미미하게 하락
                elif (df['low'][-i]>df['low'][-i-1] and red[-i]<0):
                    k=k+1   #중점 하락, 저점 상승, 마지막 파랑
                elif (df['low'][-i]>df['low'][-i-1] and red[-i]>=0):
                    n=n+1   #중점 하락, 저점 상승, 마지막 ᄈᆞᆯ강 또는 -
                elif (df['low'][-i]<=df['low'][-i-1] and red[-i]>=0):
                    k=k+1   #중점 하락, 저점 같거나 하락, 마지막 빨강 또는 -
                elif (df['low'][-i]<=df['low'][-i-1] and red[-i]<0):
                    if (i==1):
                        m=m+1   #중점 하락, 저점 같거나 하락, 마지막 파랑
                    else:
                        k=k+1
               
                
        if (n==4):
            print("rising")
        elif (n==3 & m==1 and float(format(upbit.get_balance(ticker="KRW-BTC")))>0.0001 and sell_cond/buy_price>0.00025):
            print(now)                
            upbit.sell_market_order(ticker,get_balance(ticker_origin))
            print(sell_cond ,"won up")
            print(sell_cond*100/buy_price,"% up")
            time.sleep(300)
        elif (df['high'][-1]-df['low'][-1]>=150000 and float(format(upbit.get_balance(ticker="KRW-BTC")))>0.0001 and sell_cond/buy_price>0.00025):
            print(now)            
            upbit.sell_market_order(ticker,get_balance(ticker_origin))
            print(sell_cond ,"won up.")
            print(sell_cond*100/buy_price,"% up")
            time.sleep(300)
            

        n=0
        m=0
        k=0
              
        time.sleep(2)
        
    except Exception as e:
        print(e)
        time.sleep(1)
